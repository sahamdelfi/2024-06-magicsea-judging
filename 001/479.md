Large Lead Boa

High

# Loss of Rewards for user because of the contract balance for `_rewardToken` is less than the withdraw amount.

## Summary
When the user calls `MlumStaking::withdrawFromPosition` after the Locking period ends the rewards is calculated and it transfers the reward token to the user address but when the user generated more reward than the actual current balance of `rewardToken`  in the contract then also it allows the transaction to happen and send the rewards which is there in the contractBalance and the other rewards is lost because the position is destroyed after the withdrawal .

## Vulnerability Detail
Once the user calls `MlumStaking::createPosition` the position is created in the form of NFT and that position is locked for the amount of the time user selects while creating the positon. But the problem is with the `MlumStaking::withdrawFromPosition` Because after the completion of the locking period , when the user wants to withdraw his position and if the `rewardToken` balance of the contract `MlumStaking` is less then the ***amount of the reward***  generated by the user then the user will face the loss of funds. 

Because When there is less balance in the `MlumStaking` contract then also it will allow user to withdraw his position and as ther is a function call `_destroyPosition(tokenId)` after the successfull withdrawal of full stake by the user it will destroys his position so it will not keep any records regarding that user position so user will only receive the amount in the form of rewards which is the balance of the  `MlumStaking` contract at the time of withdrawal and his other rewards which he generated will not be tracked and it will result in the loss for the user.

Let's See it by and example and a POC ::
- Here the initial balance of the `rewardToken` for `MlumStaking` is 10 tokens .
- Now user creates the position and stake his 5 tokens for 20 days.
- After 20 days now user wants to withdraw his full stake which is 5 tokens  and now it will result in loss of reward because the `rewardToken` of `MlumStaking` is less then the reward generated by the user.

Here's the POC , Run it by `forge test --mt testLessRewardTokenBalance -vvvvv` ::
```solidity
function testLessRewardTokenBalance() public {
        _rewardToken.mint(address(_pool), 10_000_000); // Balance of reward token in contract : 10 tokens
        _stakingToken.mint(ALICE, 10 ether);


        console.log("Contract initial Reward token balance:- " ,_rewardToken.balanceOf(address(_pool)));
        console.log("Alice initial Reward token balance :- ", _rewardToken.balanceOf(ALICE));
        console.log("---------------------------------------------------------------------------------");
        console.log("---------------------------------------------------------------------------------");

        // Creating Position
        vm.startPrank(ALICE);
        _stakingToken.approve(address(_pool), 5 ether);
        _pool.createPosition(5 ether, 20 days);
        vm.stopPrank();


        // Getting the struct values for token id 1
        console.log("Token id : 1");
        MlumStaking.StakingPosition memory position = _pool.getStakingPosition(1);
        console.log("staking position amount  :-", position.amount);
        console.log("staking position amountWithMultiplier:-", position.amountWithMultiplier);
        console.log("staking position lockMultiplier:-", position.lockMultiplier);
        console.log("staking position rewardDebt:-", position.rewardDebt);
        console.log("staking position totalMultiplier:-", position.totalMultiplier);
        console.log("staking position lockDuration:-", position.lockDuration);
        console.log("---------------------------------------------------------------------------------");
        console.log("---------------------------------------------------------------------------------");

        // Skipping the lock time to unlock it
        skip(20 days);

        // Alice withdrawing the position after successful lock completion
        vm.prank(ALICE);
        _pool.withdrawFromPosition(1, 5 ether);

        console.log("After the full stake withdrawal the position is destroyed.");
        MlumStaking.StakingPosition memory position2 = _pool.getStakingPosition(1);
        console.log("staking position amount :-", position2.amount);
        console.log("staking position amountWithMultiplier:-", position2.amountWithMultiplier);
        console.log("staking position lockMultiplier:-", position2.lockMultiplier);
        console.log("staking position rewardDebt:-", position2.rewardDebt);
        console.log("staking position totalMultiplier:-", position2.totalMultiplier);
        console.log("staking position lockDuration:-", position2.lockDuration);
        console.log("---------------------------------------------------------------------------------");
        console.log("---------------------------------------------------------------------------------");
        console.log("Contract Reward token balance after Withdrawal:- ", _rewardToken.balanceOf(address(_pool)));
        console.log("Alice Reward token balance after withdrawal:- ", _rewardToken.balanceOf(ALICE));
    }
```
**Output will be ::**
![image](https://github.com/sherlock-audit/2024-06-magicsea-yash-0025/assets/68538952/f39b3ece-68ba-4346-aa7b-72f70762fb0a)



## Impact
User  loosing out the rewards which he generated after staking his MLUM token in `MlumStaking` contract.

## Code Snippet
https://github.com/sherlock-audit/2024-06-magicsea/blob/main/magicsea-staking/src/MlumStaking.sol#L496-L502

## Tool used

Manual Review

Foundry

## Recommendation
Try adding require check in the `MlumStaking::_withdrawFromPosition` which is called by the `MlumStaking::withdrawFromPosition` it will revert the call if the contract balance is less than the generated rewards and the user will not incurred loss for his rewards which he generated by staking the MLUM.

```diff
 function _withdrawFromPosition(address nftOwner, uint256 tokenId, uint256 amountToWithdraw) internal {
        require(amountToWithdraw > 0, "null");
        StakingPosition storage position = _stakingPositions[tokenId];
        require(
            _unlockOperators.contains(nftOwner)
                || (position.startLockTime + position.lockDuration) <= _currentBlockTimestamp() || isUnlocked(),
            "locked"
        );
+       require(position.amount >= amountToWithdraw, "invalid");
        _harvestPosition(tokenId, nftOwner);
```
